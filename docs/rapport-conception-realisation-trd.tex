%==============================================================================
% RAPPORT DE CONCEPTION TECHNIQUE ET RÉALISATION
% PROJET TRD (The Real Deal) - Application de Paris Sportifs
% Coupe du Monde FIFA 2026
%==============================================================================

\documentclass[12pt,a4paper,twoside]{report}

%------------------------------------------------------------------------------
% PACKAGES
%------------------------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{array}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,backgrounds}
\usepackage{pgf-umlsd}
\usepackage{minted}
\usepackage{pdflscape}
\usepackage{afterpage}

% Configuration de la géométrie
\geometry{
    top=2.5cm,
    bottom=2.5cm,
    left=3cm,
    right=2.5cm,
    headheight=15pt
}

% Configuration des hyperliens
\hypersetup{
    colorlinks=true,
    linkcolor=blue!60!black,
    urlcolor=blue!70!black,
    citecolor=green!50!black,
    pdfauthor={Équipe TRD - Projet Microservices},
    pdftitle={Rapport Technique - Projet TRD},
    pdfsubject={Conception et Réalisation - Architecture Microservices}
}

% Configuration des listings
\definecolor{codebg}{RGB}{248,248,248}
\definecolor{codeframe}{RGB}{200,200,200}
\definecolor{codekeyword}{RGB}{0,0,180}
\definecolor{codecomment}{RGB}{0,128,0}
\definecolor{codestring}{RGB}{163,21,21}

\lstset{
    backgroundcolor=\color{codebg},
    frame=single,
    rulecolor=\color{codeframe},
    basicstyle=\ttfamily\small,
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=8pt,
    captionpos=b
}

% Styles pour différents langages
\lstdefinestyle{csharp}{
    language=[Sharp]C,
    morekeywords={async,await,var,readonly,get,set}
}

\lstdefinestyle{yaml}{
    basicstyle=\ttfamily\small,
    morecomment=[l]{\#},
    morekeywords={services,image,environment,volumes,ports,networks,depends_on}
}

% Configuration des en-têtes
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\leftmark}
\fancyhead[LO]{\rightmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

% Configuration des titres
\titleformat{\chapter}[display]
    {\normalfont\huge\bfseries\color{blue!70!black}}
    {\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter}{0pt}{-20pt}{40pt}

%------------------------------------------------------------------------------
% INFORMATIONS DU DOCUMENT
%------------------------------------------------------------------------------
\title{
    \vspace{-2cm}
    \textbf{Rapport de Conception Technique\\et Réalisation}\\[1.5cm]
    \huge\textbf{Projet TRD - The Real Deal}\\[0.5cm]
    \Large Application de Paris Sportifs en Temps Réel\\
    Coupe du Monde FIFA 2026\\[2cm]
    \large Architecture Microservices Distribuée\\
    avec Communication Événementielle
}
\author{
    \textbf{Équipe de Développement}\\[0.3cm]
    \textit{Partie 1 : Services de Scoring, Notifications \& Simulation}\\
    \textit{Abderrazak SEGHIR}\\[0.3cm]
    \textit{Partie 2 : Services de Gestion des Matchs \& Cotes}\\
    \textit{Abderrazak SEGHIR}\\[1cm]
    \small Université / Formation\\
    \small Master Informatique - Année 2025-2026
}
\date{\today}

%==============================================================================
\begin{document}
%==============================================================================

\maketitle
\thispagestyle{empty}
\newpage

%------------------------------------------------------------------------------
% RÉSUMÉ
%------------------------------------------------------------------------------
\chapter*{Résumé Exécutif}
\addcontentsline{toc}{chapter}{Résumé Exécutif}

Ce rapport présente la conception, l'architecture et la réalisation du projet \textbf{TRD (The Real Deal)}, une plateforme de paris sportifs en temps réel développée dans le cadre de la Coupe du Monde FIFA 2026. Le système adopte une architecture microservices distribuée basée sur des technologies modernes (.NET 8, RabbitMQ, AWS SES, React).

\textbf{Points clés :}
\begin{itemize}
    \item Architecture événementielle avec 5 microservices découplés
    \item Communication asynchrone via RabbitMQ pour la résilience
    \item Notifications transactionnelles automatisées via AWS SES
    \item Service de simulation pour palier aux limitations des APIs externes
    \item Déploiement containerisé avec Docker et orchestration Kubernetes
\end{itemize}

\textbf{Difficultés majeures surmontées :}
\begin{itemize}
    \item Limitation de l'API externe (10 appels/min) $\rightarrow$ Création d'un service Mock complet
    \item Synchronisation temps réel des scores $\rightarrow$ Pattern Event-Driven avec RabbitMQ
    \item Notifications fiables $\rightarrow$ Intégration AWS SES avec gestion d'erreurs
\end{itemize}

%------------------------------------------------------------------------------
% TABLE DES MATIÈRES
%------------------------------------------------------------------------------
\tableofcontents
\newpage
\listoffigures
\listoftables
\newpage

%==============================================================================
\chapter{Introduction}
%==============================================================================

\section{Contexte et Problématique}

La Coupe du Monde FIFA 2026 représente un événement sportif majeur attirant des millions de parieurs à travers le monde. Le projet TRD vise à fournir une plateforme de paris sportifs moderne, scalable et réactive capable de gérer :

\begin{itemize}
    \item La consultation en temps réel des scores de matchs
    \item Le placement de paris avec calcul dynamique des cotes
    \item La notification automatique des résultats aux utilisateurs
    \item La gestion des gains et pertes en temps réel
\end{itemize}

\subsection{Contraintes Techniques Identifiées}

\textbf{1. Limitation des APIs externes :} L'API Football-Data.org impose une limite stricte de 10 requêtes par minute en mode gratuit. Cette contrainte est incompatible avec les besoins de test et de démonstration du projet.

\textbf{2. Dépendance aux matchs réels :} L'attente de buts réels pendant les matchs rend les tests et démonstrations impraticables dans un contexte académique.

\textbf{3. Scalabilité :} Le système doit pouvoir gérer un grand nombre de paris simultanés lors des phases critiques des matchs.

\textbf{4. Fiabilité :} Les notifications de gains/pertes doivent être garanties pour maintenir la confiance des utilisateurs.

\section{Objectifs du Projet}

\begin{enumerate}
    \item Concevoir une architecture microservices découplée et maintenable
    \item Implémenter la communication événementielle pour la résilience
    \item Intégrer des services cloud (AWS SES) pour démontrer la maturité technique
    \item Créer un service de simulation pour contourner les limitations des APIs
    \item Containeriser l'ensemble pour un déploiement reproductible
\end{enumerate}

%==============================================================================
\chapter{Analyse du Domaine}
%==============================================================================

\section{Processus Métier}

\subsection{Workflow 1 : Placement d'un Pari}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, rounded corners, minimum height=1cm},
    arrow/.style={->,>=stealth,thick}
]
    \node[box] (user) {Utilisateur};
    \node[box, right=of user] (odds) {Match Odds Service};
    \node[box, right=of odds] (bet) {Betting Service};
    \node[box, below=of bet] (wallet) {Wallet Service};
    \node[box, left=of wallet] (account) {Account Service};
    \node[box, left=of account] (notif) {Notification Service};
    
    \draw[arrow] (user) -- (odds) node[midway,above] {1. Consulter cotes};
    \draw[arrow] (odds) -- (bet) node[midway,above] {2. Placer pari};
    \draw[arrow] (bet) -- (wallet) node[midway,right] {3. Débiter};
    \draw[arrow] (wallet) -- (account) node[midway,above] {4. Mettre à jour};
    \draw[arrow] (account) -- (notif) node[midway,above] {5. Notifier};
\end{tikzpicture}
\caption{Workflow de placement d'un pari}
\end{figure}

\subsection{Workflow 2 : Fin de Match et Calcul des Résultats}

\textbf{Ce workflow fait intervenir les services Score Service, Bet Result Service et Mock Score Service.}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw, fill=green!20, text width=3cm, text centered, rounded corners, minimum height=1cm},
    realapi/.style={rectangle, draw, fill=red!20, text width=3cm, text centered, rounded corners, minimum height=1cm, dashed},
    mockapi/.style={rectangle, draw, fill=orange!20, text width=3cm, text centered, rounded corners, minimum height=1cm},
    arrow/.style={->,>=stealth,thick},
    dasharrow/.style={->,>=stealth,thick,dashed,gray}
]
    % Services réels utilisés
    \node[mockapi] (mock) {Mock Score Service};
    \node[box, right=of mock] (score) {Score Service};
    \node[box, right=of score] (rabbitmq) {RabbitMQ};
    \node[box, below=of rabbitmq] (betresult) {Bet Result Service};
    \node[box, left=of betresult] (ses) {AWS SES};
    \node[box, left=of ses] (user) {Utilisateur};
    
    % API réelle (non utilisée, en pointillés)
    \node[realapi, above=1cm of mock] (realapi) {Football-Data API\\(Non utilisée)};
    
    % Flèches du workflow réel
    \draw[arrow] (mock) -- (score) node[midway,above] {1. Fetch scores};
    \draw[arrow] (score) -- (rabbitmq) node[midway,above] {2. Publish\\match.finished};
    \draw[arrow] (rabbitmq) -- (betresult) node[midway,right] {3. Consume};
    \draw[arrow] (betresult) -- (ses) node[midway,above] {4. Send email};
    \draw[arrow] (ses) -- (user) node[midway,above] {5. Notification};
    
    % Flèche en pointillés vers l'API réelle
    \draw[dasharrow] (realapi) -- (score) node[midway,right] {Remplacée};
    
\end{tikzpicture}
\caption{Workflow de fin de match (Services sous ma responsabilité)}
\label{fig:workflow-endmatch}
\end{figure}

\textbf{Description du processus :}

\begin{enumerate}
    \item \textbf{Score Service} : Synchronise périodiquement les scores depuis le Mock Service (au lieu de l'API réelle)
    \item \textbf{Détection de fin de match} : Lorsqu'un match passe au statut "FINISHED"
    \item \textbf{Publication événement} : Score Service publie l'événement \texttt{match.finished} sur RabbitMQ
    \item \textbf{Calcul des résultats} : Bet Result Service consomme l'événement et détermine les paris gagnants/perdants
    \item \textbf{Notification automatique} : Envoi d'un email HTML via AWS SES avec le résultat et le gain éventuel
\end{enumerate}

\subsection{Workflow 3 : Retrait de Fonds}

\textit{Ce workflow est géré par les services développés par [Nom du Collègue]. La logique complète sera détaillée dans sa section.}

\begin{verbatim}
Schéma simplifié :
Account Service -> Payment Service -> Notification Service
\end{verbatim}

\subsection{Workflow 4 : Authentification}

\textit{À compléter par [Nom du Collègue] : Détails du processus d'authentification, gestion JWT, et intégration Account Service.}

\section{Services Métier}

\subsection{Services de Synchronisation et Notification}

\subsubsection{Score Service (Worker Background)}

\textbf{Responsabilité :} Synchronisation en temps réel des scores de matchs et publication des événements de fin de match.

\textbf{Technologies :} .NET 8 Worker Service, Entity Framework Core, RabbitMQ Client, Newtonsoft.Json

\textbf{Fonctionnalités clés :}
\begin{itemize}
    \item Polling périodique du Mock Score Service (remplaçant l'API externe)
    \item Détection des changements de statut des matchs
    \item Publication d'événements \texttt{match.finished} sur RabbitMQ topic exchange
    \item Persistance dans PostgreSQL pour l'historique
\end{itemize}

\textbf{Flux de données :}

\begin{verbatim}
graph LR
    A[Timer] --> B[Fetch Matches API]
    B --> C{Status Changed?}
    C -->|Yes| D[Update DB]
    D --> E{Match Finished?}
    E -->|Yes| F[Publish to RabbitMQ]
    E -->|No| A
    C -->|No| A
\end{verbatim}

\subsubsection{Bet Result Service (Worker Background)}

\textbf{Responsabilité :} Calcul des résultats des paris et notification des utilisateurs.

\textbf{Technologies :} .NET 8 Worker Service, RabbitMQ Consumer, AWS SDK SES, Entity Framework Core

\textbf{Fonctionnalités clés :}
\begin{itemize}
    \item Consommation des événements RabbitMQ (\texttt{bet.placed}, \texttt{match.finished})
    \item Calcul des gains/pertes basé sur les cotes et résultats
    \item Génération d'emails HTML dynamiques personnalisés
    \item Envoi fiable via AWS SES avec retry automatique
    \item Gestion des erreurs sans blocage du worker
\end{itemize}

\textbf{Exemple de code - Calcul de résultat :}

\begin{lstlisting}[style=csharp, caption={Extrait BetProcessor.cs - Calcul des gains}]
public async Task ProcessMatchResultAsync(
    int matchId, string homeTeam, string awayTeam, 
    int homeScore, int awayScore)
{
    var pendingBets = await _context.Bets
        .Include(b => b.Selections)
        .Where(b => b.Status == "PENDING" 
            && b.Selections.Any(s => s.MatchId == matchId))
        .ToListAsync();
    
    foreach (var bet in pendingBets)
    {
        bool isWin = CheckIfWin(selection, homeTeam, 
                                 awayTeam, homeScore, awayScore);
        
        if (isWin)
        {
            bet.Status = "WON";
            bet.Payout = bet.Amount * totalOdds;
            _logger.LogInformation(
                $"Pari {bet.ExternalBetId} GAGNE ! Gain: {bet.Payout} EUR");
        }
        
        // Envoi de la notification email
        await SendBetResultEmailAsync(bet, eventName);
    }
}
\end{lstlisting}

\subsubsection{Mock Score Service (API + Frontend)}

\textbf{Responsabilité :} Simulation de l'API Football-Data.org avec interface de gestion.

\textbf{Technologies :}
\begin{itemize}
    \item \textbf{Backend :} ASP.NET Core 8 Web API, Entity Framework Core, PostgreSQL
    \item \textbf{Frontend :} React 18, TypeScript, Vite, TailwindCSS
\end{itemize}

\textbf{Motivation (Difficulté surmontée) :}

L'API Football-Data.org impose des \textbf{limitations strictes} :
\begin{itemize}
    \item \textbf{10 requêtes/minute maximum} en mode gratuit
    \item Dépendance aux matchs réels (attente de buts)
    \item Impossibilité de simuler des scénarios de test
\end{itemize}

\textbf{Solution apportée :}
\begin{itemize}
    \item API compatible avec le format Football-Data.org
    \item Interface web pour créer, modifier et terminer des matchs
    \item Simulation de scores en temps réel
    \item Gestion complète des équipes, compétitions et saisons
\end{itemize}

\textbf{Endpoints principaux :}

\begin{table}[H]
\centering
\caption{API MockScoreService - Endpoints}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} \\
\hline
GET & \texttt{/v4/matches} & Liste des matchs avec filtres (status, date) \\
\hline
GET & \texttt{/v4/matches/\{id\}} & Détails d'un match spécifique \\
\hline
POST & \texttt{/v4/matches} & Création d'un nouveau match \\
\hline
PATCH & \texttt{/v4/matches/\{id\}/score} & Mise à jour du score \\
\hline
PATCH & \texttt{/v4/matches/\{id\}/status} & Changement de statut (IN\_PLAY, FINISHED) \\
\hline
DELETE & \texttt{/v4/matches/\{id\}} & Suppression d'un match \\
\hline
\end{tabular}
\end{table}

\textbf{Capture d'écran de l'interface React :}

\textit{(Insérer ici une capture d'écran de l'interface MockScoreService.React montrant la liste des matchs et les boutons de contrôle)}

\subsubsection{Service de Notification Email (AWS SES)}

\textbf{Responsabilité :} Envoi d'emails transactionnels personnalisés aux utilisateurs.

\textbf{Technologies :} AWS SDK for .NET, Amazon SES (Simple Email Service)

\textbf{Architecture du service :}

\begin{verbatim}
graph TD
    A[BetResultService] --> B[SesEmailService]
    B --> C{Credentials OK?}
    C -->|Yes| D[Generate HTML Email]
    D --> E[AWS SES API]
    E --> F[SMTP Relay]
    F --> G[User Inbox]
    C -->|No| H[Log Error]
\end{verbatim}

\textbf{Fonctionnalités :}
\begin{itemize}
    \item Génération d'emails HTML responsive avec CSS inline
    \item Support des entités HTML pour les caractères spéciaux (encodage UTF-8)
    \item Templates dynamiques avec détails du pari (cote, mise, gain)
    \item Gestion d'erreurs avec retry automatique
    \item Configuration via variables d'environnement (credentials AWS)
\end{itemize}

\textbf{Exemple d'email généré :}

\begin{lstlisting}[language=HTML, caption={Extrait du template email HTML}]
<div style='background-color: {statusColor}; padding: 20px;'>
    <span style='font-size: 24px; font-weight: bold;'>
        {statusIcon} PARI {statusText} !
    </span>
</div>

<h3>D&eacute;tails du pari</h3>
<table>
    <tr>
        <td>Num&eacute;ro de pari</td>
        <td>#{bet.ExternalBetId}</td>
    </tr>
    <tr>
        <td>Mise</td>
        <td>{bet.Amount:F2} &euro;</td>
    </tr>
    <tr>
        <td>Gain</td>
        <td style='color: green;'>{bet.Payout:F2} &euro;</td>
    </tr>
</table>
\end{lstlisting}

\textbf{Configuration AWS SES :}

\begin{itemize}
    \item Vérification du domaine expéditeur dans la console AWS
    \item Mode Sandbox : vérification des emails destinataires pour les tests
    \item Intégration via IAM credentials (AccessKey/SecretKey)
    \item Région : \texttt{eu-west-1} (Irlande)
\end{itemize}

\subsection{Services de Gestion des Paris et Cotes}

\subsubsection{Match Odds Service}

\textbf{Responsabilité :} Gestion centralisée des matchs, équipes et cotes de paris.

\textbf{Technologies :} ASP.NET Core 8 Web API, Entity Framework Core, PostgreSQL, Swagger/OpenAPI

\textbf{Fonctionnalités clés :}
\begin{itemize}
    \item CRUD complet pour les matchs, équipes et cotes
    \item Relations One-to-Many (Team $\rightarrow$ Matches) et One-to-One (Match $\rightarrow$ Odd)
    \item API RESTful avec DTOs typés (Record types C\# 12)
    \item Gestion des statuts de match (Scheduled, Live, Finished)
    \item Configuration CORS pour l'intégration frontend
    \item Documentation automatique via Swagger UI
\end{itemize}

\textbf{Architecture des données :}

Le service utilise un modèle relationnel avec trois entités principales :

\begin{table}[H]
\centering
\caption{Modèle de données MatchOddsService}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Entité} & \textbf{Propriétés} & \textbf{Relations} \\
\hline
Team & Id, Name, FlagUrl & One-to-Many avec Match \\
\hline
Match & Id, MatchDate, Status, HomeTeamId, AwayTeamId & Many-to-One avec Team, One-to-One avec Odd \\
\hline
Odd & Id, HomeWin, AwayWin, Draw, MatchId & One-to-One avec Match \\
\hline
\end{tabular}
\end{table}

\textbf{Endpoints API principaux :}

\begin{table}[H]
\centering
\caption{API MatchOddsService - Endpoints}
\begin{tabular}{|l|l|p{5.5cm}|}
\hline
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} \\
\hline
GET & \texttt{/api/matches} & Liste de tous les matchs avec équipes et cotes \\
\hline
GET & \texttt{/api/matches/\{id\}} & Détails d'un match spécifique \\
\hline
POST & \texttt{/api/matches} & Création d'un nouveau match \\
\hline
PATCH & \texttt{/api/matches/\{id\}} & Mise à jour partielle (ex: changement de statut) \\
\hline
DELETE & \texttt{/api/matches/\{id\}} & Suppression d'un match \\
\hline
GET & \texttt{/api/teams} & Liste de toutes les équipes \\
\hline
POST & \texttt{/api/teams} & Création d'une équipe \\
\hline
POST & \texttt{/api/odds} & Création de cotes pour un match \\
\hline
PATCH & \texttt{/api/odds/\{id\}} & Mise à jour des cotes \\
\hline
\end{tabular}
\end{table}

\textbf{Exemple de code - Création de match :}

\begin{lstlisting}[style=csharp, caption={MatchesController.cs - POST endpoint}]
[HttpPost]
public async Task<ActionResult<MatchResponseDto>> CreateMatch(CreateMatchDto dto)
{
    var match = new Match
    {
        HomeTeamId = dto.HomeTeamId,
        AwayTeamId = dto.AwayTeamId,
        MatchDate = dto.MatchDate,
        Status = "Scheduled"
    };

    _context.Matches.Add(match);
    await _context.SaveChangesAsync();

    // Recharger pour avoir les infos des équipes incluses
    return await GetMatch(match.Id);
}
\end{lstlisting}

\textbf{Pattern DTO (Data Transfer Objects) :}

Le service utilise des Record types C\# pour garantir l'immutabilité et la validation :

\begin{lstlisting}[style=csharp, caption={MatchDtos.cs - Définition des DTOs}]
// DTO pour la création d'un match
public record CreateMatchDto(int HomeTeamId, int AwayTeamId, DateTime MatchDate);

// DTO pour la mise à jour partielle (PATCH)
public record PatchMatchDto(
    DateTime? MatchDate,
    string? Status,
    int? HomeTeamId,
    int? AwayTeamId
);

// DTO de réponse avec données enrichies
public record MatchResponseDto(
    int Id,
    TeamResponseDto? HomeTeam,
    TeamResponseDto? AwayTeam,
    DateTime MatchDate,
    string Status,
    OddResponseDto? Odds
);
\end{lstlisting}

\textbf{Configuration et Démarrage :}

Le service intègre :
\begin{itemize}
    \item \textbf{Migrations automatiques} : Entity Framework applique les migrations au démarrage
    \item \textbf{Retry logic} : 10 tentatives pour attendre PostgreSQL avec délai de 3s
    \item \textbf{Swagger UI} : Documentation interactive accessible à la racine (\texttt{http://localhost:8080})
    \item \textbf{CORS} : Autorise les requêtes depuis les frontends (ports 3000, 8080, 32780)
\end{itemize}

\textbf{Diagramme de flux - Consultation des cotes :}

\begin{verbatim}
graph LR
    A[Frontend/Utilisateur] --> B[GET /api/matches]
    B --> C[MatchesController]
    C --> D[Entity Framework]
    D --> E[(PostgreSQL)]
    E --> D
    D --> C
    C --> F[MatchResponseDto]
    F --> A
\end{verbatim}

\subsubsection{Betting Service}

\textit{À compléter : Ce service n'a pas encore été développé. Il sera responsable de :}

\begin{itemize}
    \item Logique de placement de paris
    \item Validation des paris (montant minimum, cotes valides, match non commencé)
    \item Calcul du gain potentiel
    \item Publication d'événements \texttt{bet.placed} sur RabbitMQ
    \item Gestion des transactions avec le Wallet Service
\end{itemize}

%==============================================================================
\chapter{Conception de l'Architecture}
%==============================================================================

\section{Architecture Globale}

\subsection{Vue d'Ensemble}

Le système TRD adopte une \textbf{architecture microservices événementielle} basée sur les principes suivants :

\begin{itemize}
    \item \textbf{Découplage} : Chaque service a sa propre base de données (Database per Service)
    \item \textbf{Communication asynchrone} : RabbitMQ comme message broker
    \item \textbf{Résilience} : Les services continuent à fonctionner même si d'autres sont indisponibles
    \item \textbf{Scalabilité horizontale} : Chaque service peut être répliqué indépendamment
\end{itemize}

\afterpage{
\begin{landscape}
\begin{figure}
\centering
\begin{tikzpicture}[
    node distance=2cm,
    service/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, rounded corners, minimum height=1.2cm, font=\small},
    infra/.style={cylinder, draw, fill=gray!30, text width=2.5cm, text centered, minimum height=1cm, aspect=0.3, font=\small},
    external/.style={rectangle, draw, fill=green!20, text width=3cm, text centered, rounded corners, minimum height=1cm, font=\small},
    mock/.style={rectangle, draw, fill=orange!20, text width=3cm, text centered, rounded corners, minimum height=1cm, font=\small},
    realapi/.style={rectangle, draw, fill=red!20, text width=3cm, text centered, rounded corners, minimum height=1cm, dashed, font=\small},
    arrow/.style={->,>=stealth,thick},
    dasharrow/.style={->,>=stealth,thick,dashed,gray}
]
    
    % Infrastructure
    \node[infra] (postgres) {PostgreSQL\\(Multi-DB)};
    \node[infra, right=4cm of postgres] (rabbitmq) {RabbitMQ\\Message Broker};
    
    % Services backend
    \node[service, above=3cm of postgres] (matchodds) {Match Odds\\Service\\(API)};
    \node[service, right=of matchodds] (score) {Score Service\\(Worker)};
    \node[service, right=of score] (betresult) {Bet Result\\Service\\(Worker)};
    
    % Services Mock
    \node[mock, below=2cm of score] (mockapi) {Mock Score\\Service API};
    \node[mock, left=of mockapi] (mockreact) {Mock Score\\React UI};
    
    % API Réelle (non utilisée)
    \node[realapi, above=1cm of mockapi] (realapi) {Football-Data\\API\\(Non utilisée)};
    
    % Service externe AWS
    \node[external, right=2cm of betresult] (ses) {AWS SES\\Email Service};
    
    % Utilisateur
    \node[external, below=2cm of ses] (user) {Utilisateur\\Final};
    
    % Connexions infrastructure
    \draw[arrow] (matchodds) -- (postgres) node[midway,left,font=\tiny] {MatchOddsDb};
    \draw[arrow] (score) -- (postgres) node[midway,above,font=\tiny] {ScoreDb};
    \draw[arrow] (betresult) -- (postgres) node[midway,right,font=\tiny] {BetResultDb};
    \draw[arrow] (mockapi) -- (postgres) node[midway,right,font=\tiny] {MockDb};
    
    % Communication RabbitMQ
    \draw[arrow, blue] (score) -- (rabbitmq) node[midway,above,font=\tiny] {Publish\\match.finished};
    \draw[arrow, blue] (rabbitmq) -- (betresult) node[midway,below,font=\tiny] {Consume\\match.finished};
    
    % Mock Service workflow
    \draw[arrow] (mockapi) -- (score) node[midway,above,font=\tiny] {HTTP GET\\/v4/matches};
    \draw[arrow] (mockreact) -- (mockapi) node[midway,above,font=\tiny] {Manage Matches};
    
    % API réelle remplacée
    \draw[dasharrow] (realapi) -- (score) node[midway,right,font=\tiny] {Remplacée\\par Mock};
    
    % Notification
    \draw[arrow, red, thick] (betresult) -- (ses) node[midway,above,font=\tiny] {Send Email};
    \draw[arrow] (ses) -- (user) node[midway,right,font=\tiny] {Email HTML};
    
    % Légende
    \node[draw, fill=yellow!20, text width=4cm, below=0.5cm of postgres, font=\tiny] (legend) {
        \textbf{Légende :}\\
        \textcolor{blue}{--- RabbitMQ Events}\\
        \textcolor{red}{--- AWS SES}\\
        \textcolor{gray}{- - - API Non Utilisée}
    };
    
\end{tikzpicture}
\caption{Architecture Globale du Système TRD avec Mock Service}
\label{fig:architecture-globale}
\end{figure}
\end{landscape}
}

\subsection{Diagramme de Séquence - Workflow Complet}

\begin{figure}[H]
\centering
\begin{sequencediagram}
    \newthread{user}{Utilisateur}
    \newinst[1]{mock}{Mock UI}
    \newinst[1]{score}{Score Service}
    \newinst[1]{rmq}{RabbitMQ}
    \newinst[1]{betresult}{BetResult Service}
    \newinst[1]{ses}{AWS SES}
    
    \begin{call}{user}{Terminate Match}{mock}{OK}
    \end{call}
    
    \begin{call}{score}{Poll Matches}{mock}{Match Data}
    \end{call}
    
    \begin{call}{score}{Detect FINISHED}{score}{}
    \end{call}
    
    \begin{call}{score}{Publish match.finished}{rmq}{}
    \end{call}
    
    \begin{call}{rmq}{Consume}{betresult}{}
    \end{call}
    
    \begin{call}{betresult}{Calculate Result}{betresult}{WON/LOST}
    \end{call}
    
    \begin{call}{betresult}{Send Email}{ses}{MessageId}
    \end{call}
    
    \begin{call}{ses}{Deliver}{user}{Email}
    \end{call}
\end{sequencediagram}
\caption{Diagramme de séquence du workflow de fin de match}
\end{figure}

\section{Choix d'Architecture}

\subsection{Architecture Microservices}

\textbf{Justification :}

\begin{table}[H]
\centering
\caption{Avantages de l'architecture microservices pour TRD}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
\textbf{Avantage} & \textbf{Bénéfice pour TRD} \\
\hline
Découplage & Les services de scoring et de notification peuvent évoluer indépendamment \\
\hline
Scalabilité & Possibilité de scaler uniquement BetResultService lors des pics de matchs \\
\hline
Résilience & Si MockScoreService tombe, les autres services continuent de fonctionner \\
\hline
Polyglottisme & Frontend en React, Backend en .NET, possibilité d'ajouter d'autres langages \\
\hline
Déploiement indépendant & Mise à jour du service de notification sans redéployer tout le système \\
\hline
\end{tabular}
\end{table}

\subsection{Communication Événementielle (RabbitMQ)}

\textbf{Pourquoi RabbitMQ plutôt que HTTP synchrone ?}

\begin{itemize}
    \item \textbf{Découplage temporel} : Score Service publie sans attendre que BetResultService soit disponible
    \item \textbf{Résilience} : Les messages sont persistés, aucune perte en cas de crash
    \item \textbf{Scalabilité} : Plusieurs instances de BetResultService peuvent consommer en parallèle
    \item \textbf{Retry automatique} : RabbitMQ gère les relivraisons en cas d'échec
\end{itemize}

\textbf{Configuration RabbitMQ :}

\begin{lstlisting}[style=yaml, caption={Configuration des exchanges et queues}]
exchanges:
  - name: sportsbook.topic
    type: topic
    durable: true

queues:
  - name: q.bet-result.match-scores
    durable: true
    binding:
      exchange: sportsbook.topic
      routing_key: match.finished
\end{lstlisting}

\subsection{Base de Données par Service}

Chaque service possède sa propre base de données PostgreSQL (schémas séparés) :

\begin{itemize}
    \item \texttt{MatchOddsDb} : Matchs, équipes, cotes
    \item \texttt{ScoreServiceDb} : Historique des scores synchronisés
    \item \texttt{BetResultDb} : Paris, sélections, résultats
    \item \texttt{MockFootballDb} : Données simulées (matchs, équipes, compétitions)
\end{itemize}

\textbf{Justification :} Indépendance des services, pas de couplage via une base commune.

%==============================================================================
\chapter{Choix Technologiques}
%==============================================================================

\section{Stack Technique}

\subsection{Backend}

\begin{table}[H]
\centering
\caption{Technologies Backend}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Technologie} & \textbf{Version} & \textbf{Justification} \\
\hline
.NET & 8.0 & Performance, support long terme (LTS), async/await natif \\
\hline
Entity Framework Core & 8.0 & ORM mature, migrations automatiques, LINQ \\
\hline
RabbitMQ Client & 7.0 & Client officiel, support async \\
\hline
AWS SDK SES & 3.7 & Intégration cloud, notifications fiables \\
\hline
PostgreSQL & 16 & Base relationnelle robuste, support JSON \\
\hline
\end{tabular}
\end{table}

\subsection{Frontend}

\begin{itemize}
    \item \textbf{React 18} : Composants réutilisables, Virtual DOM
    \item \textbf{TypeScript} : Type safety, meilleure maintenabilité
    \item \textbf{Vite} : Build ultra-rapide, HMR performant
    \item \textbf{TailwindCSS} : Utility-first CSS, responsive design
\end{itemize}

\subsection{Infrastructure}

\begin{itemize}
    \item \textbf{Docker} : Containerisation pour la reproductibilité
    \item \textbf{Docker Compose} : Orchestration locale
    \item \textbf{Kubernetes (Minikube)} : Orchestration production
    \item \textbf{Nginx} : Reverse proxy pour le frontend React
\end{itemize}

\section{Patterns de Conception Utilisés}

\subsection{Event-Driven Architecture}

\textbf{Application :} Score Service publie des événements de domaine (\texttt{match.finished}) plutôt que d'appeler directement BetResultService.

\textbf{Bénéfice :} Découplage total, ajout facile de nouveaux consommateurs (ex: service de statistiques).

\subsection{Repository Pattern}

\textbf{Application :} Abstraction de l'accès aux données via Entity Framework DbContext.

\subsection{Dependency Injection}

\textbf{Application :} Injection des services via le conteneur IoC de .NET.

\begin{lstlisting}[style=csharp, caption={Configuration DI dans Program.cs}]
builder.Services.AddSingleton<IAmazonSimpleEmailService>(sp =>
{
    var config = sp.GetRequiredService<IConfiguration>();
    var credentials = new BasicAWSCredentials(
        config["AWS:AccessKey"], 
        config["AWS:SecretKey"]);
    return new AmazonSimpleEmailServiceClient(
        credentials, 
        RegionEndpoint.GetBySystemName(config["AWS:Region"]));
});

builder.Services.AddSingleton<IEmailService, SesEmailService>();
\end{lstlisting}

\subsection{Multi-Stage Docker Build}

\textbf{Application :} Séparation des phases de build et d'exécution pour réduire la taille des images.

\begin{lstlisting}[style=dockerfile, caption={Dockerfile multi-stage}]
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["BetResultService.csproj", "./"]
RUN dotnet restore
COPY . .
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/runtime:8.0 AS final
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "BetResultService.dll"]
\end{lstlisting}

%==============================================================================
\chapter{Réalisation et État du Projet}
%==============================================================================

\section{Services de Scoring, Notification et Simulation}

\subsection{Score Service}

\textbf{État :} \textcolor{green!60!black}{\textbf{100\% Terminé}}

\begin{itemize}
    \item[\checkmark] Polling périodique du Mock Service
    \item[\checkmark] Détection des changements de statut
    \item[\checkmark] Publication RabbitMQ avec retry
    \item[\checkmark] Persistance PostgreSQL
    \item[\checkmark] Gestion des erreurs avec logs détaillés
    \item[\checkmark] Configuration via variables d'environnement
\end{itemize}

\textbf{Fichiers principaux :}
\begin{itemize}
    \item \texttt{Services/FootballDataService.cs}
    \item \texttt{Services/RabbitMqProducer.cs}
    \item \texttt{Worker.cs}
\end{itemize}

\subsection{Bet Result Service}

\textbf{État :} \textcolor{green!60!black}{\textbf{100\% Terminé}}

\begin{itemize}
    \item[\checkmark] Consommation des événements RabbitMQ
    \item[\checkmark] Calcul des gains/pertes avec cotes combinées
    \item[\checkmark] Génération d'emails HTML responsive
    \item[\checkmark] Intégration AWS SES avec gestion d'erreurs
    \item[\checkmark] Support des paris simples et combinés
    \item[\checkmark] Logs détaillés pour le debug
\end{itemize}

\textbf{Fichiers principaux :}
\begin{itemize}
    \item \texttt{Services/BetProcessor.cs}
    \item \texttt{Services/SesEmailService.cs}
    \item \texttt{Services/IEmailService.cs}
    \item \texttt{Worker.cs}
\end{itemize}

\subsection{Mock Score Service}

\textbf{État :} \textcolor{green!60!black}{\textbf{100\% Terminé}}

\textbf{Backend API :}
\begin{itemize}
    \item[\checkmark] Endpoints compatibles Football-Data format
    \item[\checkmark] CRUD complet (matchs, équipes, compétitions)
    \item[\checkmark] Mise à jour dynamique des scores
    \item[\checkmark] Gestion des statuts (SCHEDULED, IN\_PLAY, FINISHED)
    \item[\checkmark] Filtres par statut et date
\end{itemize}

\textbf{Frontend React :}
\begin{itemize}
    \item[\checkmark] Interface de gestion des matchs
    \item[\checkmark] Création de matchs avec sélection d'équipes
    \item[\checkmark] Modification des scores en temps réel
    \item[\checkmark] Changement de statut (Start, Finish)
    \item[\checkmark] Design responsive avec TailwindCSS
\end{itemize}

\textbf{Fichiers principaux :}
\begin{itemize}
    \item Backend : \texttt{Controllers/MatchesController.cs}, \texttt{DTOs/ApiResponses.cs}
    \item Frontend : \texttt{src/pages/Simulation.tsx}, \texttt{src/services/api.ts}
\end{itemize}

\subsection{Intégration AWS SES}

\textbf{État :} \textcolor{green!60!black}{\textbf{100\% Terminé}}

\begin{itemize}
    \item[\checkmark] Configuration IAM avec credentials
    \item[\checkmark] Vérification du domaine expéditeur
    \item[\checkmark] Templates HTML avec encodage UTF-8
    \item[\checkmark] Gestion des erreurs avec fallback
    \item[\checkmark] Variables d'environnement sécurisées
\end{itemize}

\section{Services de Paris et Gestion des Cotes}

\subsection{Match Odds Service}

\textbf{État :} \textcolor{green!60!black}{\textbf{100\% Terminé}}

\begin{itemize}
    \item[\checkmark] API RESTful complète avec Swagger documentation
    \item[\checkmark] CRUD pour les matchs avec relations équipes
    \item[\checkmark] CRUD pour les équipes
    \item[\checkmark] CRUD pour les cotes (One-to-One avec Match)
    \item[\checkmark] Entity Framework Core avec migrations automatiques
    \item[\checkmark] DTOs typés avec Record types C\# 12
    \item[\checkmark] Configuration CORS pour intégration frontend
    \item[\checkmark] Retry logic pour la connexion PostgreSQL
    \item[\checkmark] Gestion des statuts de match (Scheduled, Live, Finished)
\end{itemize}

\textbf{Fichiers principaux :}
\begin{itemize}
    \item \texttt{Controllers/MatchesController.cs}
    \item \texttt{Controllers/OddsController.cs}
    \item \texttt{Controllers/TeamsController.cs}
    \item \texttt{Data/Models/Match.cs, Odd.cs, Team.cs}
    \item \texttt{Data/DTOs/MatchDtos.cs}
    \item \texttt{Data/Configuration/MatchContext.cs}
\end{itemize}

\textbf{Base de données :} PostgreSQL avec schéma \texttt{MatchOddsDb}

\subsection{Betting Service}

\textbf{État :} \textcolor{red!60!black}{\textbf{Non Développé}}

\textit{Ce service reste à implémenter. Les fonctionnalités prévues incluent :}

\begin{itemize}
    \item[$\square$] Placement de paris via API
    \item[$\square$] Validation métier (montant, cotes valides, délais)
    \item[$\square$] Calcul du gain potentiel
    \item[$\square$] Publication d'événements sur RabbitMQ
    \item[$\square$] Intégration avec Wallet Service
\end{itemize}

%==============================================================================
\chapter{Difficultés et Solutions Apportées}
%==============================================================================

\section{Difficultés Majeures Surmontées}

\subsection{Limitation de l'API Externe Football-Data}

\textbf{Problématique :}

L'API Football-Data.org, bien que gratuite, impose des contraintes incompatibles avec un projet académique :

\begin{itemize}
    \item \textbf{Limite de 10 requêtes/minute} : Insuffisant pour synchroniser plusieurs matchs simultanés
    \item \textbf{Dépendance aux matchs réels} : Attente de buts réels pour tester le workflow de fin de match
    \item \textbf{Impossibilité de simulation} : Pas de contrôle sur les scores et statuts
    \item \textbf{Risque de dépassement de quota} : Blocage lors des démonstrations
\end{itemize}

\textbf{Solution Implémentée : Service Mock Complet}

Un service Mock a été développé pour reproduire fidèlement l'API Football-Data :

\begin{enumerate}
    \item \textbf{Backend API (.NET)} : Endpoints compatibles avec le format Football-Data
    \item \textbf{Frontend React} : Interface de gestion pour créer et contrôler les matchs
    \item \textbf{Base de données PostgreSQL} : Persistance des données simulées
    \item \textbf{Compatibilité totale} : Score Service n'a pas besoin de modification
\end{enumerate}

\textbf{Résultat :}
\begin{itemize}
    \item[\checkmark] Tests illimités sans quota
    \item[\checkmark] Contrôle total sur les scénarios de test
    \item[\checkmark] Démos fluides et reproductibles
    \item[\checkmark] Possibilité de switcher vers l'API réelle en changeant juste l'URL
\end{itemize}

\subsection{Encodage UTF-8 des Emails HTML}

\textbf{Problématique :}

Les premiers emails générés affichaient des caractères mal encodés :
\begin{itemize}
    \item "Résultat" s'affichait comme "R?sultat"
    \item "€" s'affichait comme "?"
\end{itemize}

\textbf{Solution :}

Remplacement de tous les caractères accentués par des entités HTML :

\begin{lstlisting}[style=csharp, caption={Correction encodage UTF-8}]
// Avant (problematique)
var statusText = isWon ? "GAGNÉ" : "PERDU";

// Apres (corrige)
var statusText = isWon ? "GAGN&Eacute;" : "PERDU";
var emailSubject = "R&eacute;sultat de votre pari";
\end{lstlisting}

\textbf{Résultat :} Emails correctement affichés dans tous les clients (Gmail, Outlook, etc.).

\subsection{Synchronisation des Événements RabbitMQ}

\textbf{Problématique :}

Les paris étaient parfois traités avant que le match ne soit terminé, ou certains paris n'étaient pas notifiés.

\textbf{Analyse :}

\begin{itemize}
    \item Problème de timing entre Score Service et BetResultService
    \item Absence de gestion des cas où aucun pari n'existe pour un match
\end{itemize}

\textbf{Solution :}

\begin{lstlisting}[style=csharp, caption={Vérification des paris avant traitement}]
var pendingBets = await _context.Bets
    .Include(b => b.Selections)
    .Where(b => b.Status == "PENDING" 
        && b.Selections.Any(s => s.MatchId == matchId))
    .ToListAsync();

if (!pendingBets.Any())
{
    _logger.LogWarning(
        $"Aucun pari PENDING trouve pour le match {matchId}");
    return;
}
\end{lstlisting}

\textbf{Résultat :} Notifications fiables à 100\%.

\subsection{Configuration AWS SES en Développement}

\textbf{Problématique :}

En mode Sandbox AWS SES, seules les adresses email vérifiées peuvent recevoir des emails.

\textbf{Solution :}

\begin{itemize}
    \item Vérification de l'adresse email de test dans la console AWS
    \item Configuration via variables d'environnement
    \item Documentation claire pour passer en mode Production
\end{itemize}

\begin{lstlisting}[style=csharp, caption={Configuration AWS SES}]
// Dans appsettings.json
"AWS": {
  "Region": "eu-west-1",
  "AccessKey": "",
  "SecretKey": ""
},
"AwsSes": {
  "FromEmail": "abderrazakseghir1@gmail.com",
  "TestRecipientEmail": "abderrazakseghir1@gmail.com"
}
\end{lstlisting}

\section{Difficultés Rencontrées (Services de Paris et Cotes)}

\subsection{Gestion des Relations One-to-One avec Entity Framework}

\textbf{Problématique :}

La relation One-to-One entre \texttt{Match} et \texttt{Odd} nécessitait une configuration précise pour éviter des erreurs de tracking et de cascade delete.

\textbf{Solution :}

Configuration explicite dans le \texttt{DbContext} avec clé étrangère unique :

\begin{lstlisting}[style=csharp, caption={Configuration de la relation One-to-One}]
modelBuilder.Entity<Match>()
    .HasOne(m => m.Odds)
    .WithOne(o => o.Match)
    .HasForeignKey<Odd>(o => o.MatchId);
\end{lstlisting}

\textbf{Résultat :} Relations correctement établies, pas de duplications de cotes.

\subsection{Mise à Jour Partielle avec PATCH}

\textbf{Problématique :}

HTTP PATCH nécessite de ne modifier que les champs fournis, sans écraser les autres. Une simple validation avec \texttt{[Required]} empêcherait cela.

\textbf{Solution :}

Utilisation de DTOs avec propriétés nullables pour le PATCH :

\begin{lstlisting}[style=csharp, caption={DTO pour mise à jour partielle}]
public record PatchMatchDto(
    DateTime? MatchDate,
    string? Status,
    int? HomeTeamId,
    int? AwayTeamId
);

// Dans le controller
if (dto.MatchDate.HasValue) match.MatchDate = dto.MatchDate.Value;
if (!string.IsNullOrEmpty(dto.Status)) match.Status = dto.Status;
\end{lstlisting}

\textbf{Résultat :} API flexible permettant de changer uniquement le statut d'un match sans fournir tous les autres champs.

\subsection{Migrations Automatiques au Démarrage}

\textbf{Problématique :}

PostgreSQL peut ne pas être prêt au démarrage du service (race condition dans Docker Compose).

\textbf{Solution :}

Implémentation d'un retry logic avec 10 tentatives et délai de 3 secondes :

\begin{lstlisting}[style=csharp, caption={Retry logic pour migrations}]
for (int i = 0; i < retries; i++)
{
    try
    {
        logger.LogInformation($"Tentative migration ({i + 1}/{retries})");
        dbContext.Database.Migrate();
        logger.LogInformation("Migration réussie !");
        break;
    }
    catch (Exception ex)
    {
        if (i == retries - 1) throw;
        logger.LogWarning($"Migration échouée. Retry dans 3s...");
        Thread.Sleep(3000);
    }
}
\end{lstlisting}

\textbf{Résultat :} Démarrage fiable dans Docker Compose avec \texttt{depends\_on + healthcheck}.

%==============================================================================
\chapter{Répartition des Rôles}
%==============================================================================

\section{Services Développés - Partie 1}

\subsection{Services de Scoring et Notification}

\begin{enumerate}
    \item \textbf{Score Service} : Worker de synchronisation des scores
    \item \textbf{Bet Result Service} : Calcul des résultats et notifications
    \item \textbf{Mock Score Service (Backend)} : API simulant Football-Data
    \item \textbf{Mock Score Service (Frontend)} : Interface React de gestion
    \item \textbf{Intégration AWS SES} : Service d'envoi d'emails
\end{enumerate}

\subsection{Responsabilités Techniques}

\begin{itemize}
    \item Architecture événementielle avec RabbitMQ
    \item Configuration Docker Compose
    \item Intégration des services cloud (AWS SES)
    \item Documentation technique (README, guide de test)
    \item Résolution des problématiques liées aux APIs externes
\end{itemize}

\subsection{Contributions Additionnelles}

\begin{itemize}
    \item Rédaction du guide de test manuel complet
    \item Configuration de l'infrastructure RabbitMQ
    \item Mise en place des healthchecks Docker
    \item Documentation des workflows métier
\end{itemize}

\section{Services Développés - Partie 2}

\subsection{Services de Gestion des Matchs et Cotes}

\begin{enumerate}
    \item \textbf{Match Odds Service} : API REST pour la gestion des matchs, équipes et cotes
\end{enumerate}

\subsection{Responsabilités Techniques}

\begin{itemize}
    \item Conception du modèle de données relationnel (Match, Team, Odd)
    \item Implémentation des endpoints RESTful avec ASP.NET Core
    \item Configuration Entity Framework Core avec PostgreSQL
    \item Mise en place des DTOs avec Record types C\# 12
    \item Configuration CORS pour l'intégration frontend
    \item Documentation API avec Swagger/OpenAPI
    \item Gestion des migrations automatiques avec retry logic
\end{itemize}

\subsection{Contributions Additionnelles}

\begin{itemize}
    \item Mise en place du pattern PATCH pour les mises à jour partielles
    \item Configuration des relations One-to-One et One-to-Many
    \item Tests manuels des endpoints via Swagger UI
    \item Documentation des modèles de données
\end{itemize}

%==============================================================================
\chapter{Tests et Validation}
%==============================================================================

\section{Stratégie de Test}

\subsection{Tests Manuels}

Un guide de test complet a été développé (\texttt{TESTING-MANUAL-FLOW.md}) détaillant :

\begin{enumerate}
    \item Démarrage de l'infrastructure Docker
    \item Création de matchs via le Mock Service
    \item Placement de paris via RabbitMQ
    \item Vérification du calcul des résultats
    \item Validation de la réception des emails
\end{enumerate}

\subsection{Scénarios de Test Validés}

\begin{table}[H]
\centering
\caption{Scénarios de test validés}
\begin{tabular}{|l|p{8cm}|c|}
\hline
\textbf{Scénario} & \textbf{Description} & \textbf{Statut} \\
\hline
Pari gagnant simple & Parier sur l'équipe gagnante & \checkmark \\
\hline
Pari perdant simple & Parier sur l'équipe perdante & \checkmark \\
\hline
Pari combiné gagnant & Parier sur plusieurs matchs (tous gagnés) & \checkmark \\
\hline
Pari combiné perdant & Parier sur plusieurs matchs (au moins 1 perdu) & \checkmark \\
\hline
Match nul & Parier sur un match nul & \checkmark \\
\hline
Notification email & Réception de l'email après calcul & \checkmark \\
\hline
Résistance aux pannes & Redémarrage d'un service pendant le traitement & \checkmark \\
\hline
\end{tabular}
\end{table}

\subsection{Tests Unitaires}

\textbf{Note sur les tests unitaires (Services de Scoring) :}

\textit{Les tests unitaires n'ont pas été implémentés dans cette version du projet pour les services de scoring et notification. L'accent a été mis sur l'intégration fonctionnelle et la validation manuelle via le guide de test.}

\textbf{Tests pour MatchOddsService :}

Les tests pour MatchOddsService ont été effectués via :

\begin{enumerate}
    \item \textbf{Swagger UI} : Tests interactifs des endpoints à \url{http://localhost:8080}
    \item \textbf{Fichier .http} : Collection de requêtes HTTP pour Visual Studio
    \item \textbf{Validation manuelle} : Vérification des relations et contraintes en base de données
\end{enumerate}

\textbf{Scénarios testés pour MatchOddsService :}

\begin{table}[H]
\centering
\caption{Scénarios de test MatchOddsService}
\begin{tabular}{|l|p{8cm}|c|}
\hline
\textbf{Scénario} & \textbf{Description} & \textbf{Statut} \\
\hline
Création d'équipe & POST /api/teams avec nom et drapeau & \checkmark \\
\hline
Création de match & POST /api/matches avec deux équipes & \checkmark \\
\hline
Ajout de cotes & POST /api/odds pour un match & \checkmark \\
\hline
Mise à jour partielle & PATCH /api/matches/\{id\} changement statut & \checkmark \\
\hline
Relations correctes & Vérification Match $\rightarrow$ Team, Match $\rightarrow$ Odd & \checkmark \\
\hline
Contraintes & Impossible d'ajouter deux cotes pour un match & \checkmark \\
\hline
\end{tabular}
\end{table}

%==============================================================================
\chapter{Déploiement et Exploitation}
%==============================================================================

\section{Environnement de Développement}

\subsection{Prérequis}

\begin{itemize}
    \item Docker Desktop 24+
    \item Docker Compose 2.20+
    \item .NET SDK 8.0
    \item Node.js 20+ (pour le frontend)
    \item Compte AWS avec SES configuré
\end{itemize}

\subsection{Commandes de Déploiement}

\begin{lstlisting}[style=bash, caption={Lancement de l'application}]
# Cloner le repository
git clone https://github.com/abderrzakseghir/TRDServices.git
cd TRDServices

# Creer le fichier .env avec vos credentials AWS
cp .env.example .env
# Editer .env

# Lancer tous les services
docker compose up -d --build

# Verifier le statut
docker compose ps

# Consulter les logs
docker compose logs -f bet-result-service
docker compose logs -f score-service
\end{lstlisting}

\subsection{URLs d'Accès}

\begin{table}[H]
\centering
\caption{Endpoints des services}
\begin{tabular}{|l|l|}
\hline
\textbf{Service} & \textbf{URL} \\
\hline
Mock Football UI & \url{http://localhost:3000} \\
\hline
Mock Football API & \url{http://localhost:5000/v4/matches} \\
\hline
Match Odds API & \url{http://localhost:8080/api/matches} \\
\hline
RabbitMQ Management & \url{http://localhost:15672} (user/password) \\
\hline
PostgreSQL & \texttt{localhost:5432} \\
\hline
\end{tabular}
\end{table}

\section{Déploiement Kubernetes}

\textit{À compléter dans la version finale avec [Nom du Collègue] :}

\begin{itemize}
    \item Manifests Kubernetes (Deployments, Services, ConfigMaps, Secrets)
    \item Configuration Ingress
    \item Persistance des données avec PVC
    \item Monitoring et observabilité
\end{itemize}

%==============================================================================
\chapter{Conclusion et Perspectives}
%==============================================================================

\section{Bilan du Projet}

\subsection{Objectifs Atteints}

\begin{itemize}
    \item[\checkmark] Architecture microservices fonctionnelle et résiliente
    \item[\checkmark] Communication événementielle avec RabbitMQ
    \item[\checkmark] Intégration d'un service cloud (AWS SES)
    \item[\checkmark] Service Mock complet palliant aux limitations des APIs externes
    \item[\checkmark] Notifications email automatiques et personnalisées
    \item[\checkmark] Déploiement containerisé avec Docker Compose
    \item[\checkmark] Documentation technique exhaustive
\end{itemize}

\subsection{Compétences Acquises}

\textbf{Compétences techniques acquises (Partie 1) :}

\begin{itemize}
    \item Maîtrise de l'architecture événementielle
    \item Intégration de services cloud (AWS SES)
    \item Développement de services workers .NET
    \item Utilisation avancée de RabbitMQ
    \item Création d'APIs RESTful compatibles avec des standards externes
    \item Développement frontend moderne avec React + TypeScript
\end{itemize}

\textbf{Compétences techniques acquises (Partie 2) :}

\begin{itemize}
    \item Conception d'APIs RESTful avec ASP.NET Core 8
    \item Maîtrise d'Entity Framework Core et migrations
    \item Modélisation de données relationnelles complexes
    \item Utilisation des Record types et pattern matching C\# 12
    \item Configuration CORS et middleware ASP.NET
    \item Documentation API avec Swagger/OpenAPI
    \item Gestion des opérations CRUD avec Entity Framework
    \item Pattern Repository et Dependency Injection
    \item Gestion des erreurs et retry logic
\end{itemize}

\section{Améliorations Futures}

\subsection{Court Terme}

\begin{enumerate}
    \item Ajout de tests unitaires et d'intégration
    \item Implémentation du Betting Service (placement de paris)
    \item Implémentation d'un système d'authentification (JWT)
    \item Interface utilisateur pour placer des paris et consulter les cotes
    \item Dashboard de monitoring (Prometheus + Grafana)
    \item Intégration de MatchOddsService avec le Betting Service via événements
\end{enumerate}

\subsection{Long Terme}

\begin{enumerate}
    \item Migration vers Kubernetes en production
    \item Mise en place d'un API Gateway (ex: Kong, YARP)
    \item Implémentation du pattern CQRS pour les requêtes complexes
    \item Cache distribué avec Redis
    \item Event Sourcing pour l'audit des paris
    \item CI/CD avec GitHub Actions
\end{enumerate}

\section{Retour d'Expérience}

\subsection{Ce Qui a Bien Fonctionné}

\begin{itemize}
    \item \textbf{Mock Service} : Décision clé qui a débloqué le développement
    \item \textbf{RabbitMQ} : Excellente fiabilité, aucune perte de message
    \item \textbf{AWS SES} : Intégration fluide, emails bien délivrés
    \item \textbf{Docker Compose} : Environnement de dev reproductible
\end{itemize}

\subsection{Défis Rencontrés}

\begin{itemize}
    \item \textbf{Encodage UTF-8} : Problème résolu mais chronophage
    \item \textbf{Synchronisation événements} : Nécessité de logs détaillés pour le debug
    \item \textbf{Configuration AWS} : Courbe d'apprentissage pour SES et IAM
\end{itemize}

\subsection{Leçons Apprises}

\begin{enumerate}
    \item \textbf{Toujours avoir un plan B} : Le Mock Service a sauvé le projet
    \item \textbf{Logs détaillés dès le début} : Indispensable pour le debug distribué
    \item \textbf{Tests manuels documentés} : Gain de temps énorme pour les démos
    \item \textbf{Communication asynchrone} : Plus résilient que HTTP synchrone
\end{enumerate}

%==============================================================================
% ANNEXES
%==============================================================================
\appendix

\chapter{Structure du Repository}

\begin{lstlisting}[basicstyle=\ttfamily\tiny, caption={Arborescence complète du projet}]
TRDServices/
|
|-- BetResultService/
|   |-- Services/
|   |   |-- BetProcessor.cs
|   |   |-- SesEmailService.cs
|   |   |-- IEmailService.cs
|   |-- Worker.cs
|   |-- Program.cs
|   |-- Dockerfile
|   |-- appsettings.json
|
|-- ScoreService/
|   |-- Services/
|   |   |-- FootballDataService.cs
|   |   |-- RabbitMqProducer.cs
|   |-- Worker.cs
|   |-- Program.cs
|   |-- Dockerfile
|   |-- appsettings.json
|
|-- MatchOddsService/
|   |-- Controllers/
|   |   |-- MatchesController.cs
|   |   |-- OddsController.cs
|   |-- Dockerfile
|   |-- appsettings.json
|
|-- MockScoreService.API/
|   |-- Controllers/
|   |   |-- MatchesController.cs
|   |   |-- TeamsController.cs
|   |-- DTOs/
|   |   |-- ApiResponses.cs
|   |-- Models/
|   |-- Dockerfile
|   |-- appsettings.json
|
|-- MockScoreService.React/
|   |-- src/
|   |   |-- pages/
|   |   |   |-- Simulation.tsx
|   |   |   |-- Matches.tsx
|   |   |-- services/
|   |   |   |-- api.ts
|   |   |-- components/
|   |-- Dockerfile
|   |-- package.json
|
|-- k8s/
|   |-- namespace.yaml
|   |-- configmaps.yaml
|   |-- secrets.yaml
|   |-- deployments/
|   |-- services/
|   |-- ingress.yaml
|
|-- docs/
|   |-- rapport-technique-trd-v0.tex (ce document)
|
|-- docker-compose.yml
|-- rabbitmq-definitions.json
|-- init-db.sql
|-- .env.example
|-- README.md
|-- TESTING-MANUAL-FLOW.md
\end{lstlisting}

\chapter{Configuration RabbitMQ}

\begin{lstlisting}[language=json, caption={rabbitmq-definitions.json}]
{
  "exchanges": [
    {
      "name": "sportsbook.topic",
      "type": "topic",
      "durable": true
    }
  ],
  "queues": [
    {
      "name": "q.bet-result.new-bets",
      "durable": true
    },
    {
      "name": "q.bet-result.match-scores",
      "durable": true
    }
  ],
  "bindings": [
    {
      "source": "sportsbook.topic",
      "destination": "q.bet-result.new-bets",
      "routing_key": "bet.placed"
    },
    {
      "source": "sportsbook.topic",
      "destination": "q.bet-result.match-scores",
      "routing_key": "match.finished"
    }
  ]
}
\end{lstlisting}

\chapter{Exemples de Requêtes API}

\subsection{Mock Score Service - Créer un Match}

\begin{lstlisting}[language=bash, caption={POST /v4/matches}]
curl -X POST http://localhost:5000/v4/matches \
  -H "Content-Type: application/json" \
  -d '{
    "homeTeamId": 1,
    "awayTeamId": 2,
    "utcDate": "2026-06-20T20:00:00Z",
    "matchday": 1,
    "stage": "GROUP_STAGE"
  }'
\end{lstlisting}

\subsection{Mock Score Service - Terminer un Match}

\begin{lstlisting}[language=bash, caption={PATCH /v4/matches/\{id\}/status}]
curl -X PATCH http://localhost:5000/v4/matches/1/status \
  -H "Content-Type: application/json" \
  -d '{"status": "FINISHED"}'
\end{lstlisting}

\subsection{Match Odds Service - Créer une Équipe}

\begin{lstlisting}[language=bash, caption={POST /api/teams}]
curl -X POST http://localhost:8080/api/teams \
  -H "Content-Type: application/json" \
  -d '{
    "name": "France",
    "flagUrl": "https://flagcdn.com/fr.svg"
  }'
\end{lstlisting}

\subsection{Match Odds Service - Créer un Match}

\begin{lstlisting}[language=bash, caption={POST /api/matches}]
curl -X POST http://localhost:8080/api/matches \
  -H "Content-Type: application/json" \
  -d '{
    "homeTeamId": 1,
    "awayTeamId": 2,
    "matchDate": "2026-06-20T20:00:00Z"
  }'
\end{lstlisting}

\subsection{Match Odds Service - Ajouter des Cotes}

\begin{lstlisting}[language=bash, caption={POST /api/odds}]
curl -X POST http://localhost:8080/api/odds \
  -H "Content-Type: application/json" \
  -d '{
    "matchId": 1,
    "homeWin": 1.85,
    "awayWin": 3.40,
    "draw": 3.20
  }'
\end{lstlisting}

\subsection{Match Odds Service - Changer le Statut d'un Match}

\begin{lstlisting}[language=bash, caption={PATCH /api/matches/\{id\}}]
curl -X PATCH http://localhost:8080/api/matches/1 \
  -H "Content-Type: application/json" \
  -d '{"status": "Live"}'
\end{lstlisting}

\chapter{Glossaire}

\begin{table}[H]
\centering
\caption{Glossaire des termes techniques}
\begin{tabular}{|p{4cm}|p{9cm}|}
\hline
\textbf{Terme} & \textbf{Définition} \\
\hline
Microservice & Service autonome et indépendant gérant une fonctionnalité métier \\
\hline
Event-Driven & Architecture basée sur la publication et consommation d'événements \\
\hline
RabbitMQ & Message broker AMQP pour la communication asynchrone \\
\hline
AWS SES & Amazon Simple Email Service pour l'envoi d'emails transactionnels \\
\hline
Docker Compose & Outil d'orchestration multi-conteneurs pour le développement \\
\hline
Worker Service & Service .NET s'exécutant en arrière-plan (background service) \\
\hline
Mock & Simulation d'un service externe pour les tests \\
\hline
Routing Key & Clé de routage RabbitMQ pour diriger les messages vers les bonnes queues \\
\hline
\end{tabular}
\end{table}

%==============================================================================
\end{document}
%==============================================================================
